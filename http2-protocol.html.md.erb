---
title: Routing HTTP/2 and gRPC Traffic to Apps
owner: CF for VMs Networking
---

<% current_page.data.title = "Routing HTTP/2 and gRPC Traffic to Apps" %>

This topic describes how to route HTTP/2 and gRPC traffic to <%= vars.app_runtime_first %> apps.

## <a id="overview"></a> Overview



### <a id="http2"></a> HTTP/2

HTTP/2 is the second major version of the the HTTP protocol.
<%= vars.http2_support_version %>.

HTTP/2 features the following improvements over HTTP/1.1:

* Using a binary data format instead of plain text
* Compressing headers
* Multiplexing multiple HTTP requests over a single TCP connection

Together, these improvements can improve response times for some apps.

For more information about the HTTP/2 protocol, see [RFC 7540](https://datatracker.ietf.org/doc/html/rfc7540).

### <a id="grpc"></a> gRPC

gRPC is a Remote Procedure Call (RPC) framework that uses HTTP/2 as its transport medium.
It is especially useful for managing communication between apps in a microservices cluster.
For apps to serve gRPC traffic, every network hop between the client and app must use HTTP/2.

For more information, see [gRPC](https://grpc.io/).

## <a id="http2-with-cf"></a> Using HTTP/2 with <%= vars.app_runtime_abbr %> Apps

If your <%= vars.app_runtime_abbr %> deployment is configured to support HTTP/2,
then all traffic ingressing to <%= vars.app_runtime_abbr %> supports HTTP/2.
The traffic is forwarded as HTTP/1.1 before it reaches your app unless configured otherwise.
You do not need to make changes to existing apps to support HTTP/2.

<%= vars.http2_admin_link %>


#### <a id="example-1"></a> Example 1: Serving HTTP/2 for a HTTP/1.1 Application

1. Push an application that serves HTTP/1.1:

	```
	cf push my-app
	```

1. Issue a HTTP/2 request to the application:

	```
	curl my-app.example.com --http2 -v
	```

1. Note that the request and response are issued over HTTP/2.

1. Review the logs for the application:

	```
	cf logs my-app
	```

1. Note that the request to the application is issued over HTTP/1.1.

<p class="note"><strong>Note:</strong> You will need a version of curl that supports HTTP/2 in order to issue this request. </p>

### <a id="e2e-http2"></a> End-to-End HTTP/2

If you want traffic to your application to be HTTP/2 for all network hops
(for example, if you need to serve gRPC traffic),
then you will need to configure your route to send HTTP/2 traffic to your application.

When configured, traffic matching that route will always be sent to your application over HTTP/2,
regardless of original ingress protocol.
For example, external HTTP/1.1 requests will be forwarded to your application over HTTP/2.
Your app will not have the opportunity to negotiate what protocol it receives.

<p class="note"><strong>Note:</strong>
For those familiar with the HTTP/2 specification,
your application will be receiving HTTP/2 with prior knowledge,
as described in <a href="https://datatracker.ietf.org/doc/html/rfc7540#section-3.4">RFC 7540, Section 3.4</a>.</p>

There are multiple ways to configure end-to-end HTTP/2 for your application:

#### <a id="example-2"></a> Example 2: End-to-End HTTP/2 Using Application Manifest

1. Acquire an application that supports serving HTTP/2 traffic with prior knowledge.
For this example, we will use [the HTTP/2 test app from Cloud Foundry Acceptance Tests](https://github.com/cloudfoundry/cf-acceptance-tests/tree/http2_routing/assets/http2).

1. Create an application manifest, `manifest.yml`, with a route mapped to the application with HTTP/2:

	```yaml
	---
	applications:
	- name: my-app
	  routes:
	    - route: my-app.example.com
	      protocol: http2
	```

1. Push the application with the manifest:

	```
	cf push -f manifest.yml
	```

1. Issue a HTTP/2 request to the application:

	```
	curl my-app.example.com --http2 -v
	```

1. Note that the request and response are issued over HTTP/2.

1. The response from the test application will include the request's protocol.
Note that it recieved the request over HTTP/2:

	```
	Hello, /, TLS: false, Protocol: HTTP/2.0
	```

#### <a id="example-3"></a> Example 3: End-to-End HTTP/2 Using CLI

1. Acquire an application that supports serving HTTP/2 traffic with prior knowledge.
For this example, we will use [the HTTP/2 test app from Cloud Foundry Acceptance Tests](https://github.com/cloudfoundry/cf-acceptance-tests/tree/http2_routing/assets/http2).

1. Push the application without a default route:

	```
	cf push --no-route
	```

1. Map a route with destination protocol `http2`:

	```
	cf map-route my-app example.com --hostname host --destination-protocol http2
	```

1. Issue a HTTP/2 request to the application:

	```
	curl host.example.com --http2 -v
	```

1. Note that the request and response are issued over HTTP/2.

1. The response from the test application will include the request's protocol.
Note that it recieved the request over HTTP/2:

	```
	Hello, /, TLS: false, Protocol: HTTP/2.0
	```

#### <a id="example-4"></a> Example 4: Pushing a gRPC Application

1. Acquire an application that supports serving gRPC traffic.
For this example, we will use [the gRPC test app from Cloud Foundry Acceptance Tests](https://github.com/cloudfoundry/cf-acceptance-tests/tree/http2_routing/assets/grpc).

1. Push the app with HTTP/2 enabled using one of the methods described above.

1. Issues a gRPC request to the application using [grpcurl](https://github.com/fullstorydev/grpcurl):

	```
	grpcurl -vv -import-path ./test/ -proto test.proto my-app.example.com:443 test.Test.Run
	```

1. Note that the gRPC request succeeds:

	```
	Response contents:
	{
	  "body": "Hello"
	}
	```

## <a id="performance"></a> Performance

HTTP/2 can provide modest performance gains for applications that are built to take advantage of it.
This is especially true for applications that:

1. Load many resources in parallel. For example a HTML page that loads many images and/or javascript files.
1. Use large and repetitive headers.

Other applications may see only minimal or no performance increases. It is a good idea to experiment with your application to see how serving HTTP/2 will affect its performance.

See the [Cloud Foundry HTTP/2 Tile Demo App](https://github.com/Gerg/http2_tile_demo) for an example of an application that benefits from HTTP/2.

## <a id="limitations"></a> Limitations

1. End-to-end HTTP/2 is currently not available for Windows cells. Routes with HTTP/2 mappings will continue to send HTTP/1.1 traffic to applications on Windows cells.
2. Routes with [route services](https://docs.cloudfoundry.org/services/route-services.html) bound to them may not have end-to-end HTTP/2, depending on what protocols the bound service supports.
