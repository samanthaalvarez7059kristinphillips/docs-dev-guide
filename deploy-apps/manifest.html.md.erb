---
title: Deploying with Application Manifests
---

_This page assumes that you are using cf v5._

Application manifests tell `cf` what to do with applications. This includes everything from how many instances to create and how much memory to allocate to what services applications should use.

Whether or not you need a manifest depends on what you want to accomplish. For example, you must have a manifest in order to automate deployment. In simpler scenarios, a manifest may be helpful but not required.

## <a id='find-manifest'></a>How cf push Finds the Manifest ##


The `cf push` command looks for the `manifest.yml` file in the current working directory unless you give `cf` a non-standard manifest location and/or filename with the ``-f`` option.

A plain `cf push` command find the manifest when it is named manifest.yml and located in the current working directory.

~~~
$ cf push
Using manifest file manifest.yml
~~~


With the `-f` option, a path with no filename means that the filename must be `manifest.yml`.

~~~
cf push -m ./some_directory/some_other_directory/
~~~

Finally, with the `-f` option, supply the path _and_ the filename if the manifest is named something other than  `manifest.yml`.

~~~
cf push -f ./some_directory/some_other_directory/alternative_manifest.yml
~~~

## <a id='minimal-manifest'></a>A Minimal Manifest ##

You can deploy some (but not all) applications without ever using a manifest. On the other hand, creating the manifest before you deploy offers greater consistency and reproducibility than other methods.

Manifests are written in YAML. A typical manifest for a minimal application contains exactly the same information that would be produced by the interactive prompt method.

 <%= image_tag("minimal_manifest_v6.png") %>

The directory that contains the bits you want to push is a good place to put your manifest and to run `cf push`, because `cf` looks for a manifest in the current working directory.

## <a id='find-app'></a>How cf push Finds the Application ##

The manifest tells `cf` where to find the application—that is, the bits you want to push.

Consider a node app called `nifty-gui`. The `nifty-gui` directory contains a `manifest.yml` file and the bits you want to push—in this case, a file named `nifty-gui.js`.

`manifest.yml` includes a “path” line:

~~~
path: .
~~~

This path correctly directs `cf` to the application when you run `cf` from the `nifty-gui` directory. All is well as long as `manifest.yml` is located there. If you move `manifest.yml` but fail to edit the path line to reflect the change, `cf` can no longer find the application, even if `cf` can still find the manifest.


## <a id='optional-attributes'></a>Optional Attributes ##

This section explains how to describe optional application attributes in manifests.

### <a id='start-commands'></a>The command attribute ###

Depending on your application framework, `cf push` may start your application with a default command.
You can use the `command` attribute to set a custom start command.

For example:

~~~
command: bundle exec rake VERBOSE=true
~~~

### <a id='domain'></a>The domain attribute ###

Applications are always pushed to a particular Cloud Foundry instance, and each Cloud Foundry instance has a default domain.

When the domain line is omitted, `cf` assigns your application to the default domain. Use the domain line when you want your application to be served from a domain other than the default.

~~~
domain: ${target-base}
~~~

### <a id='env-block'></a>Environment variables ###

The `env` block consists of a heading, then one or more environment variable/value pairs. The variables belong to the environment of the container to which the application is deployed on the server.

For example:

~~~
env:
  RAILS_ENV: ${rails-env}
  RACK_ENV: ${rails-env}
~~~

While the application is running, you can view, set, and unset environment variables using `cf`:

~~~
cf env <app>
cf set-env <variable_name> <variable_value>
cf unset-env <variable_name> <variable_value>
~~~

Environment variables interact with manifests by somewhat complicated rules:

* When you deploy an application for the first time, `cf` reads the variables described in the environment block of the manifest, and adds them to the environment of the container where the application is deployed.

* When you stop and then restart an application, its environment variables persist.

### <a id='services-block'></a>Services ###

Applications can bind to services such as databases, messaging, and key-value stores.

Applications are deployed into App Spaces. An application can only bind to services that exist in the target App Space before the application is deployed.

The `services` block consists of a heading, then one or more service instance names.
For example:

~~~
  services:
    instance_ABC
    instance_XYZ
~~~

Service instance names are up to the creators of the service. They can convey logical information, as in `backend_queue`, or the nature of the service, as in `mysql_5.x`, or neither.

## <a id='multi-apps'></a>Describing Multiple Applications with One Manifest ##

You can deploy multiple applications with one `cf push` command by describing them in a single manifest. In doing so, you need to pay extra attention to directory structure and path lines in the manifest.

Suppose you want to deploy two applications called respectively spark and flame, and you want `cf` to create and start spark before flame. You accomplish this by listing spark first in the manifest.

In this situation there are two sets of bits you want to push. Let’s say that they are `spark.rb` in the spark directory and `flame.rb` in the flame directory. One level up, the fireplace directory contains the spark and the flame directories along with the `manifest.yml` file. Your plan is to run `cf` from `fireplace`, where you know it can find the manifest.

Now that you have changed the directory structure and manifest location, the standard path line of `path: . ` no longer works. How can you ensure that `cf` finds the bits you want to push?

The answer is to edit each path line to lead `cf` to the correct bits for an application. Assume that `cf` is run from the `fireplace` directory.

For `spark`:

~~~
path: ./spark/
~~~

For `flame`:

~~~
path: ./flame/
~~~

The manifest now consists of two applications blocks.

~~~
---
# this manifest deploys two applications
# apps are in flame and spark directories
# flame and spark are in fireplace
# cf push should be run from fireplace
applications:
- name: spark
  memory: 1G
  instances: 1
  host: flint-${random-word}
  domain: <%=vars.app_domain%>
  path: ./spark/
  services:
    petclinic-mysql:
    label: mysql
      provider: mysql
      version: n/a
      plan: dev-sandbox
- name: flame
  memory: 1G
  instances: 1
  host: burnin1234
  domain: <%=vars.app_domain%>
  path: ./flame/
  services:
    redis:
      label: redis
      provider: redis
      version: n/a
      plan: dev-sandbox
~~~


## <a id='minimize-duplication'></a>Minimizing Duplication ##

In manifests where multiple applications share settings or services, you begin to see content duplicated. While the manifests still work, duplication increases the risk of typographical errors which cause deployment to fail.

The cure for this problem is to “promote” the duplicate content—that is, to move it up above the applications block, where it need appear only once. The promoted content applies to all applications described in the manifest. Note that content _in_ the applications block overrides content _above_ the applications block, if the two conflict.

The manifest becomes shorter, more readable, and more maintainable.

Notice how much content in the manifest below has been promoted in this way.

~~~
---
# all applications use these settings and services
domain: <%=vars.app_domain%>
memory: 1G
instances: 1
services:
  springtime-mysql:
    label: mysql
    provider: mysql
    version: n/a
    plan: dev-sandbox
# specifics of each application
applications:
- name: springtock
  host: tock9876
  path: ./spring-music/build/libs/spring-music.war
- name: springtick
  subdomain: tick-${random-word}
  path: ./spring-music/build/libs/spring-music.war
~~~

In the next example we carry this principle further as we distribute content across multiple manifests.

## <a id='multi-manifests'></a>Multiple Manifests with Inheritance ##

A single manifest can describe multiple applications. Another powerful technique is to create multiple manifests with inheritance. Here, manifests have parent-child relationships such that children inherit descriptions from a parent. Children can use inherited descriptions as-is, extend them, or override them.

This technique helps in these and other scenarios:

* An application has a set of different deployment modes, such as debug, local, and public. Each deployment mode is described in child manifests that extend the settings in a base parent manifest.

* An application is packaged with a basic configuration described by a parent manifest. Users can extend the basic configuration by creating child manifests that add new properties or override those in the parent manifest.

The benefits of multiple manifests with inheritance are similar to those of minimizing duplicated content within single manifests. With inheritance, though, we “promote” content by placing it in the parent manifest.

Every child manifest must contain an “inherit” line that points to the parent manifest. Place the inherit line immediately after the three dashes at the top of the child manifest. For example, every child of a parent manifest called `base-manifest.yml` begins like this:

~~~
---
inherit: base-manifest.yml
~~~

You do not need to add anything to the parent manifest.

Content in the child manifest overrides content in the parent manifest, if the two conflict.

In the simple example below, a parent manifest gives each application minimal resources, while a production child manifest scales them up.

**simple-base-manifest.yml**

~~~
---
path: .
domain: <%=vars.app_domain%>
memory: 256M
instances: 1
services:
 singular-mysql:
  label: mysql
  provider: mysql
  version: n/a
  plan: dev-sandbox

# app-specific configuration
applications:
 - name: springtock
   host: springtock333
   path: ./spring-music/build/libs/spring-music.war
 - name: petclinic
   subdomain: petclinic-${random-word}
   path: ./grails-petclinic/target/pets4u-0.1.war
~~~

**simple-prod-manifest.yml**

~~~
---
inherit: simple-base-manifest.yml
applications:
 - name: not-springtock
   memory: 512M
   instances: 1
   host: dontlookatme-${random-word}
   path: ./spring-music/build/libs/spring-music.war
 - name: not-petclinic
   memory: 1G
   instances: 2
   host: meneither-${random-word}
   path: ./grails-petclinic/target/pets4u-0.1.war
~~~

Powerful as it is, inheritance can increase the potential for confusion. It’s a good idea to add comments which explain precisely how the child manifest extends or overrides the descriptions in the parent manifest.



