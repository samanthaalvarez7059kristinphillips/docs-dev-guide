<div id="js-quick-links" >
  <div class="quick-links">
    <ul>
      <li><a href="#pre">Prerequisite</a></li>
      <li><a href="#create">Create and Bind a Service Instance</a></li>
      <li><a href="#app">Access the Volume Service from your App</a></li>
      <li><a href="#nfs">NFS Volume Service</a></li>
    </ul>
  </div>
</div>

This topic describes how <%= vars.first_product_name %> app developers can read and write to a mounted file system from their apps. In <%= vars.product_name %>, a volume service provides a volume so your app can read or write to a reliable, non-ephemeral file system.

## <a id="pre"></a> Prerequisite

Before you can use a volume service with your app, <%= vars.admin %> must add a volume service to your deployment. <%= vars.add_volumes_link %>

You can run the Cloud Foundry Command Line Interface (cf CLI) `cf marketplace` command to determine if any volume services are available. See the following example output of the NFS volume service:

<pre class="terminal">
$ cf marketplace
service   plans      description
nfs       Existing   Service for connecting to NFS volumes
</pre>

If no volume service that fits your requirements exists, contact <%= vars.admin %>.

## <a id="create"></a> Create and Bind a Service Instance

To use a volume service deployed by <%= vars.admin %>, you must first create an instance of the specific volume service that you need. Follow the instructions below to create this service instance.

1. In a terminal window, run `cf create-service SERVICE-NAME PLAN SERVICE-INSTANCE -c SHARE-JSON` to create a service instance. Replace the following with the specified values:
  * `SERVICE`: The name of the volume service that you want to use.
  * `PLAN`: The name of the service plan. Service plans are a way for providers to offer varying levels of resources or features for the same service.
  * `SERVICE-INSTANCE`:  A name you provide for your service instance. Use any series of alpha-numeric characters, hyphens, and underscores. You can rename the instance at any time.
  * `SHARE-JSON` (NFS Only): If you create an instance of the NFS volume service, you must supply an extra parameter, `share`, by using the `-c` flag with a JSON string, in-line or in a file. This parameter forwards information to the broker about the NFS server and share required for the service. 
  
    The following example shows creating an instance of the "Existing" NFS 
    service plan, passing an in-line JSON string: 
    <pre class="terminal">$ cf create-service nfs Existing nfs\_service\_instance -c '{"share": "10.10.10.10/export/myshare"}'</pre>

1. Run `cf bind-service YOUR-APP SERVICE-NAME -c GID-AND-UID-JSON MOUNT-PATH READ-ONLY-TRUE` to bind your service instance to an app. Replace the following with the specified values:
  * `YOUR-APP`: The name of the <%= vars.product_name %> app for which you want to use the volume service. 
  * `SERVICE-NAME`: The name of the volume service instance you created in the previous step.
  * `GID-AND-UID-JSON` (NFS only): If you bind an instance of the NFS volume service, you must supply two extra parameters, `gid` and `uid`. You can specify these parameters with the `-c` flag and a JSON string, in-line or from a file. This parameter specifies the `gid` and `uid` to use when mounting the share to the app.
  * `MOUNT-PATH` (Optional): To mount the volume to a particular path within your app rather than the default path, you supply the `mount` parameter. Choose a path with a root-level folder that already exists in the container, such as `/home`, `/usr`, or `/var`.
  * `READ-ONLY-TRUE` (Optional): When you issue the `cf bind-service` command, Volume Services mounts a read-write file system by default. You can specify a read-only mount by adding `"readonly":true` to the bind configuration JSON string. 
<p class='note warning'><strong>Warning</strong>: Due to an underlying kernel defect, read-only NFS mounts show as <code>"mode": "rw"</code>, not <code>"mode": "ro"</code>.</p>

    The following example shows binding `my-app` to the `nfs_service_instance` and specifying a read-only volume to be mounted to `/var/volume1`,
    passing an in-line JSON string:
    <pre class="terminal">$ cf bind-service my-app nfs\_service\_instance -c '{"uid":"1000","gid":"1000","mount":"/var/volume1","readonly":true}'</pre>
    If you use an LDAP server, you must specify `username` and `password` instead of a UID and GID in this command. For example:
    <pre class="terminal">$ cf bind-service my-app nfs\_service\_instance -c '{"username":"user1000","password":"secret","mount":"/var/volume1","readonly":true}'</pre>

1. Run `cf restage YOUR-APP` to complete the service binding by restaging your app. Replace `YOUR-APP` with the name of your app.
  <pre class="terminal">$ cf restage my-app</pre>

## <a id='app'></a> Access the Volume Service from your App

To access the volume service from your app, you must know which file path to use in your code. You can view the file path in the details of the service binding, which are available from the [VCAP_SERVICES](../deploy-apps/environment-variable.html#view-env) environment variable. Follow the steps below.

1. Run `cf env YOUR-APP` to view environment variables for your app. Replace `YOUR-APP` with the name of your app.
  <pre class="terminal">
  $ cf env my-app
  "VCAP\_SERVICES": {
    "nfs": [
      {
        "credentials": {},
        "label": "nfs",
        "name": "nfs\_service\_instance",
        "plan": "Existing",
        "provider": null,
        "syslog\_drain\_url": null,
        "tags": [
        "nfs"
        ],
        "volume\_mounts": [
          {
            "container\_dir": "/var/vcap/data/153e3c4b-1151-4cf7-b311-948dd77fce64",
            "device\_type": "shared",
            "mode": "rw"
          }
        ]
      }
    ]
  }
  </pre>
  <p class='note warning'><strong>Warning</strong>: Due to an underlying kernel defect, read-only NFS mounts show as <code>"mode": "rw"</code>, not <code>"mode": "ro"</code>.</p>

2. Use the properties under `volume_mounts` for any information your app needs. Refer to the following table:
  <table>
    <tr>
      <th>
        Property
      </th>
      <th>
        Description
      </th>
    </tr>
    <tr>
      <td><code>container\_dir</code></td>
      <td>String containing the path to the mounted volume that you bound to your app.</td>
    </tr>
    <tr>
      <td><code>device\_type</code></td>
      <td>The NFS volume release. This currently only supports `shared` devices. A `shared` device represents a distributed file system that can mount on all app instances simultaneously.</td>
    </tr>
    <tr>
      <td><code>mode</code></td>
      <td>String that informs what type of access your app has to NFS, either read-only, <code>ro</code>, or read and write, <code>rw</code>.<br><br>
		Due to an underlying kernel defect, read-only NFS mounts show as <code>"mode": "rw"</code>.
		</td>
    </tr>
  </table>

## <a id='nfs'></a> NFS Volume Service

### Create an NFS volume service
* To create an NFS volume service, type the following:

    ```bash
    $ cf create-service nfs Existing myVolume -c '{"share":"<server>/<share>"}'
    $ cf services
    ```
* Substitute the nfs address of your server and share, taking care to omit the `:` that ordinarily follows the server name in the address.

#### NFS v4 (Experimental):

The Existing `nfs` volume service is provided by a libfuse implementation that only supports nfsv3 and has some performance constraints.

If you require nfsv4 or better performance or both then you can try the new nfsv4 (experimental) support offered through a new nfsbroker plan called `nfs-experimental`.  The `nfs-experimental` plan accepts a `version` parameter to determine which nfs protocol version to use.

* type the following:

    ```bash
    $ cf create-service nfs-experimental Existing myVolume -c '{"share":"<server>/<share>","version":"4.1"}'
    $ cf services
    ```

### Deploy the pora test app, first by pushing the source code to CloudFoundry
* Clone this github repo and push the pora test application:

    ```bash
    $ cd ~/workspace
    $ git clone https://github.com/cloudfoundry/persi-acceptance-tests.git
    $ cd ~/workspace/persi-acceptance-tests/assets/pora
    $ cf push pora --no-start
    ```

* Bind the service to your app supplying the correct uid and gid corresponding to what is seen on the nfs server.

    ```bash
    $ cf bind-service pora myVolume -c '{"uid":"1000","gid":"1000"}'
    ```
   > #### Bind Parameters
   > * **uid** and **gid:** When binding the nfs service to the application, the uid and gid specified are supplied to the nfs driver.  The nfs driver tranlates the application user id and group id to the specified uid and gid when sending traffic to the nfs server, and translates this uid and gid back to the running user uid and default gid when returning attributes from the server.  This allows you to interact with your nfs server as a specific user while allowing Cloud Foundry to run your application as an arbitrary user.
   > * **mount:** By default, volumes are mounted into the application container in an arbitrarily named folder under /var/vcap/data.  If you prefer to mount your directory to some specific path where your application expects it, you can control the container mount path by specifying the `mount` option.  The resulting bind command would look something like
   > ``` cf bind-service pora myVolume -c '{"uid":"0","gid":"0","mount":"/var/path"}'```
   > * **readonly:** Set true if you want the mounted volume to be read only.
   >
   > As of nfs-volume-release version 1.3.1, bind parameters may also be specified in configuration during service instance creation.  Specifying bind parameters in advance when creating the service instance is particularly helpful when binding services to an application in the application manifest, where bind configuration is not supported.

* Start the application

    ```bash
    $ cf start pora
    ```

### Test the app to make sure that it can access your NFS volume
* to check if the app is running, `curl http://pora.YOUR.DOMAIN.com` should return the instance index for your app
* to check if the app can access the shared volume `curl http://pora.YOUR.DOMAIN.com/write` writes a file to the share and then reads it back out again.

### File Locking via flock() and lockf()/fcntl()
If your application relies on file locking either through unix system calls such as flock() and fcntl() or through script commands such as `flock` **please be aware that the lock will not be enforced across diego cells**.  This is because the file locking implementations in the underlying fuse-nfs executable are not implemented, so locking is limited to local locks between precesses on the same VM.  If you have a legitimate requirement for file locking, please document your use case in a comment on [this github issue](https://github.com/cloudfoundry-incubator/nfs-volume-release/issues/13) and we'll see what we can do.

### LDAP Support

If you Cloud Foundry deploynet has been cofigured with LDAP you can also bind using LDAP credentials instead of uid/gid.  Testing this will be more or less the same as before, except that when you bind your application to your volume, you must specify `username` and `password` instead of UID and GID.

```bash
$ cf create-service nfs Existing myVolume -c '{"share":"<server>/<share>"}'
$ cf bind-service pora myVolume -c '{"username":"<username>","password":"<password>"}'
```

## Credential Rotation

Note that user credentials will be stored as part of the service binding and checked whenever an application is placed on a cell.  Hence, if the password changes on your
LDAP server, the  application must be re-bound to the service and restaged, otherwise it will fail the next time the application is restarted or scaled.