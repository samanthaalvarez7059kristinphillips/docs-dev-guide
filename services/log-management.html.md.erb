---
title: Third-Party Log Management Services
---

_This page assumes that you are using cf v6._

Third-party solutions allow you to view and analyze logs from your application to satisfy compliance or other business requirements.
Providers whose products or services work with Cloud Foundry include Logentries, logstash, Papertrail, and Splunk.
To your application, the logging solution is a service.
Their relationship can be described in terms of source, sink, and drain:

* The application is an information source.
* The logging service is an information sink.
* A drain configured on the application helps the source communicate with the sink.

Your notion of source should include the system components that interact with the app, not just the app itself.
For any one application, logs come from each instance of the app and also from Cloud Foundry system components.
For example, when a Cloud Foundry Router routes an HTTP request to an app, the Router records that event in a log.
Logs tell you both what your app does and what the system does with your app.

The Loggregator component of Cloud Foundry consolidates all logs of actions that directly affect the app.
In the Command Line Interface (CLI), you can view the entire Loggregator output or filter it to select a subset of logging information.
If you plan to use a third-party log management service, learn how to view logs in the CLI first.

Loggregator keeps a limited amount of logging information in memory; the limit depends on the hardware where Cloud Foundry is deployed.
Eventually the newest logging information replaces the oldest.
If it crashes and restarts, Loggregator retains no logging information from before the crash.
To persist larger amounts of logs, set up your application to drain logs to a third-party logging service as described [below](#use).

## <a id='cli'></a>Preparation: Viewing Logs in the Command Line Interface ##

The `cf logs` command enables you to view logs in the CLI.
You can view all the logging information that Loggregator has or receives, or filter it using shell commands.
The log output examples below are edited for brevity.

**Note**: The filtering examples use the Linux `grep` command.
Depending on your operating system and shell, you may need to use a different command or syntax.

1. `cf logs <app_name>` displays all of the logging information that Loggregator receives in (almost) real time.

	<pre class="terminal">
	$ cf logs nifty-gui
		Connected, tailing logs for app nifty-gui in org janclouduser / space jancloudspace as admin...
		2014-02-06T12:00:19.44-0800 [API]     OUT Updated app with guid c8612fc2-85b1-464c-92f5-d4a1156eacbf ({"route"=>"2ef5796b-475a-4615-9c71-75bbe277022e"})
		2014-02-06T12:00:27.54-0800 [DEA]     OUT Got staging request for app with id c8612fc2-85b1-464c-92f5-d4a1156eacbf
		2014-02-06T12:00:28.51-0800 [API]     OUT Updated app with guid c8612fc2-85b1-464c-92f5-d4a1156eacbf ({"state"=>"STARTED"})
		2014-02-06T12:00:28.69-0800 [STG]     OUT -----> Downloaded app package (552K)
		2014-02-06T12:00:49.67-0800 [App/0]   ERR [2014-02-06 20:00:49] INFO  WEBrick 1.3.1
		2014-02-06T12:01:15.63-0800 [RTR]     OUT nifty-gui.23.22.211.63.xip.io - [06/02/2014:20:01:15 +0000] "GET / HTTP/1.1" 200 44 "-" "curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8y zlib/1.2.5" 10.180.180.220:39648 response_time:0.019625952 app_id:c8612fc2-85b1-464c-92f5-d4a1156eacbf
	</pre>

1. `cf logs <app_name> --recent` displays all the logging information that Loggregator possesses at that moment.

	<pre class="terminal">
  	$ cf logs --recent nifty-gui
  	Connected, dumping recent logs for app nifty-gui in org janclouduser / space jancloudspace as admin...

  		2014-02-06T11:06:20.70-0800 [RTR]     OUT copy.23.22.211.63.xip.io - [06/02/2014:19:06:20 +0000] "GET / HTTP/1.1" 200 44 "-" "Fabula/1.00 [en] (X11; I; Praefator 3.0.3)" 10.180.180.220:57620 response_time:0.007610524 app_id:9801d83d-709b-45c9-bfdc-2565329dfb9a
  		2014-02-06T11:06:20.70-0800 [App/0]   ERR 204.15.0.254, 10.180.180.220 - - [06/Feb/2014 19:06:20] "GET / HTTP/1.1" 200 44 0.0004
  		2014-02-06T11:06:20.70-0800 [RTR]     OUT copy.23.22.211.63.xip.io - [06/02/2014:19:06:20 +0000] "GET / HTTP/1.1" 200 44 "-" "Fabula/1.00 [en] (X11; I; Praefator 3.0.3)" 10.180.180.220:57625 response_time:0.008446913 app_id:9801d83d-709b-45c9-bfdc-2565329dfb9a
  		2014-02-06T11:06:20.87-0800 [App/0]   ERR 204.15.0.254, 10.180.180.220 - - [06/Feb/2014 19:06:20] "GET / HTTP/1.1" 200 44 0.0005
  		2014-02-06T11:06:20.87-0800 [RTR]     OUT copy.23.22.211.63.xip.io - [06/02/2014:19:06:20 +0000] "GET / HTTP/1.1" 200 44 "-" "Fabula/1.00 [en] (X11; I; Praefator 3.0.3)" 10.180.180.220:57627 response_time:0.006277213 app_id:9801d83d-709b-45c9-bfdc-2565329dfb9a
  		2014-02-06T11:06:20.87-0800 [App/0]   ERR 204.15.0.254, 10.180.180.220 - - [06/Feb/2014 19:06:20] "GET / HTTP/1.1" 200 44 0.0003
	</pre>

1. Filter log messages by log type. The possibilities are described in Types of Logs below. Our example filter restricts output to messages from the second instance of an app (APP/1).

	<pre class="terminal">
	$ cf logs nifty-gui --recent | grep App/1
	2014-02-07T10:57:55.88-0800 [App/1]   OUT Express server started
	2014-02-07T10:57:55.88-0800 [App/1]   ERR
	2014-02-07T11:43:01.55-0800 [App/1]   OUT Express server started
	2014-02-07T11:43:01.55-0800 [App/1]   ERR
	</pre>

1. Filter log messages by channel. The two possibilities are standard out (`STD`)  and standard error (`ERR`). Our example filters for ERR messages only.

	<pre class="terminal">
	$ cf logs nifty-gui --recent | grep ERR
	2014-02-07T10:54:35.97-0800 [STG]     ERR
	2014-02-07T10:54:46.31-0800 [App/0]   ERR
	2014-02-07T10:57:55.88-0800 [App/1]   ERR
	2014-02-07T11:42:49.86-0800 [STG]     ERR
	2014-02-07T11:43:01.50-0800 [App/0]   ERR
	2014-02-07T11:43:01.55-0800 [App/1]   ERR
	2014-02-07T11:43:01.95-0800 [App/2]   ERR
	</pre>

1. Filter log messages by HTTP method. The possibilities depend on your app. Our example filters for HTTP GET events only.

	<pre class="terminal">
	$ cf logs nifty-gui --recent | grep GET
	2014-02-07T11:59:02.25-0800 [RTR]     OUT nifty-gui.<%=vars.app_domain%> - [07/02/2014:19:59:02 +0000] "GET / HTTP/1.1" 200 12 "-" "curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8y zlib/1.2.5" 10.10.2.181:45610 response_time:0.002682034 app_id:4d397313-20e0-478a-9a74-307446eb7640
	2014-02-07T10:59:13.13-0800 [RTR]     OUT nifty-gui.<%=vars.app_domain%> - [07/02/2014:18:59:13 +0000] "GET / HTTP/1.1" 200 12 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.107 Safari/537.36" 10.10.66.101:36928 response_time:0.012257917 app_id:4d397313-20e0-478a-9a74-307446eb7640
	2014-02-07T10:59:13.29-0800 [RTR]     OUT nifty-gui.<%=vars.app_domain%> - [07/02/2014:18:59:13 +0000] "GET /favicon.ico HTTP/1.1" 404 23 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.107 Safari/537.36" 10.10.66.101:6625 response_time:0.003119610 app_id:4d397313-20e0-478a-9a74-307446eb7640
	2014-02-07T11:30:20.03-0800 [RTR]     OUT nifty-gui.<%=vars.app_domain%> - [07/02/2014:19:30:20 +0000] "GET / HTTP/1.1" 200 12 "-" "curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8y zlib/1.2.5" 10.10.66.101:42516 response_time:0.008333640 app_id:4d397313-20e0-478a-9a74-307446eb7640
	2014-02-07T11:35:57.28-0800 [RTR]     OUT nifty-gui.<%=vars.app_domain%> - [07/02/2014:19:35:57 +0000] "GET / HTTP/1.1" 200 12 "-" "Wget/1.14 (darwin12.5.0)" 10.10.66.101:12787 response_time:0.005691659 app_id:4d397313-20e0-478a-9a74-307446eb7640
	</pre>

1. Filter log messages by timestamp. The possibilities depend on your app. Our example filters for messages emitted between 11:40 and 11:50 in the morning of February 7th, 2014, US Pacific time (indicated by the `-0800`).

	<pre class="terminal">
	$ cf logs nifty-gui --recent | grep 2014-02-07T11:4
	2014-02-07T11:42:21.90-0800 [STG]     OUT -----> Building runtime environment
	2014-02-07T11:42:48.28-0800 [STG]     OUT -----> Uploading droplet (5.6M)
	2014-02-07T11:42:49.55-0800 [DEA]     OUT Starting app instance (index 0) with guid 4d397313-20e0-478a-9a74-307446eb7640
	2014-02-07T11:42:49.64-0800 [DEA]     OUT Starting app instance (index 1) with guid 4d397313-20e0-478a-9a74-307446eb7640
	2014-02-07T11:42:49.83-0800 [DEA]     OUT Starting app instance (index 2) with guid 4d397313-20e0-478a-9a74-307446eb7640
	2014-02-07T11:42:49.86-0800 [App/0]   OUT Express server started
	2014-02-07T11:42:50.87-0800 [App/0]   ERR
	2014-02-07T11:42:50.87-0800 [App/1]   OUT Express server started
	2014-02-07T11:42:50.87-0800 [App/1]   ERR
	2014-02-07T11:42:51.49-0800 [App/2]   ERR
	2014-02-07T11:42:51.49-0800 [App/2]   OUT Express server started
	</pre>

## <a id='use'></a>Using a Third-Party Log Management Service ##

The overall process of enabling your application and the relevant Cloud Foundry components to drain logs to a third-party log management service looks like this:

1. Configure the log management solution to treat your application as a source of data.

1. Create a user-provided service instance appropriate for the log management solution.

1. Bind the service instance to the application.

Review the rest of this section to learn how to complete each of these steps.

### <a id='config'></a>Configure the service to accept traffic from Cloud Foundry ###

You must configure the third-party log management service to accept traffic from your Cloud Foundry.

To do this you need the external IP addresses of the two NAT boxes from which your Cloud Foundry will send log traffic to the service.
Ask your Cloud Foundry administrator for these IP addresses.
(NAT boxes are systems responsible for Network Address Translation, not to be confused with the NATS messaging protocol.)

You also need to obtain the special URL, called a syslog URL, that the service makes available as an endpoint for incoming log data.
This URL has a protocol of `syslog` and includes a port number.
For example:

 `syslog://logs.example.com:1234`

Cloud Foundry uses the syslog URL to route messages to the service.

Further configuration details may vary depending on service provider.

### <a id='create'></a>Create a user-provided service instance with a syslog drain ###

Now you need a service instance to bind to your app.
In this case, you create a user-provided service instance using the `cups` command with the `-l` option and the syslog URL you obtained earlier.
See [User-Provided Services] (./user-provided.html#user-cups).

Now that the service instance and the syslog drain exist, you are ready to bind the service instance to the app.

### <a id='bind'></a>Bind the service instance to the application ###

Use the `cf bind-service` command followed by `cf push` as described in [Binding User-Provided Service Instances to Applications](user-provided.html#cups-example).

## <a id='verify'></a>Verifying that Logs are Draining to a Service ##

Suppose you have completed the procedure described in the previous section and want to verify that logs are draining correctly to a third-party log management service.
One basic technique you can employ is to take actions that you know should produce log messages, and then comparing the logs you see in the CLI against those that the service shows you.
For example, assuming that your application has web pages, you could send HTTP requests to the application.

**Note**: For security reasons, Cloud Foundry applications do _not_ respond to ping.

## <a id='types'></a> Types of Logs ##

We identify different types of logs by origin.
Every Cloud Foundry component that generates logs identifies itself with a three-letter code.
Some components use more than one code because they emit more than one type of log.
Applications use the code APP/0 (“app instance zero”) for the first instance and increment the digit for every instance after that.
These codes appear in the second field, enclosed in square brackets, in logs you view in the CLI.
The primary types of logs and their codes are as follows:

<style type="text/css">
.table {font-size:12px;color:#333333;width:100%;border-width: 1px;border-color: #729ea5;border-collapse: collapse;}
.table th {font-size:12px;background-color:#acc8cc;border-width: 1px;padding: 8px;border-style: solid;border-color: #729ea5;text-align:center;}
.table tr {background-color:#d4e3e5;}
.table td {font-size:12px;border-width: 1px;padding: 8px;border-style: solid;border-color: #729ea5;}
.table tr:hover {background-color:#ffffff;}
</style>

<table border="1">

	<colgroup>
		<col>
		<col>
		<col>
	</colgroup>
	<tbody>
		<tr>
			<th>
				Origin
			</th>
			<th style="text-align: center;" ">
				Code
			</th>
			<th style="text-align: center;" ">
				Notes
			</th>
		</tr>
		<tr>
			<td>
				Application and instance
			</td>
			<td>
				APP/0
			</td>
			<td>
				0 is the first instance, 1 is the second, and so on.
			</td>
		</tr>
		<tr>
			<td>
				Cloud Controller
			</td>
			<td>
				API
			</td>
			<td>

			</td>
		</tr>
		<tr>
			<td>
				Staging
			</td>
			<td>
				STG
			</td>
			<td>
				The DEA emits these messages beginning when you deploy an app, and ending once the droplet has been uploaded.
			</td>
		</tr>
		<tr>
			<td>
				Droplet Execution Agent
			</td>
			<td>
				DEA
			</td>
			<td>
				The DEA emits these messages beginning when it starts the app.
			</td>
		</tr>
		<tr>
			<td>
				Router
			</td>
			<td>
				RTR
			</td>
			<td>

			</td>
		</tr>
	</tbody>
</table>

## <a id='format'></a> The Syslog Protocol and How Syslog Messages are Transmitted  ##

Loggregator formats logging data that it sends to third-party services according to [RFC 5424](http://tools.ietf.org/html/rfc5424), titled *The Syslog Protocol*.
Logs viewed in the CLI are not in syslog format.
Third-Party Log Management Software is defined in [RFC 6587](http://tools.ietf.org/html/rfc6587), titled *Transmission of Syslog Messages over TCP*.
